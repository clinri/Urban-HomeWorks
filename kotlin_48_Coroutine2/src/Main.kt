import kotlinx.coroutines.*

fun main() {
    task1()
    task2()
}

/**
 * 1. Написать программу покупки продукта в магазине.
 * Она запускается с фразы "Программа покупки продуктов".
 * Далее через секундную задержку предлагает оплатить товар: "Купить товар:\n1.Да\n2.Нет".
 * Если да, то запускается корутина, в которой идет процесс оплаты:
 * "Оплата продукта началась"-> через 2 сек -> "Сканирование и обработка..." -> через 2 сек ->"Покупка оплачена."
 * Если нет, то запускается корутина отмены оплаты:
 * "Отмена покупки..." -> через 2 сек ->"Покупка отменена."
 * В любом другом случае – выходит ошибка.
 * Написать корутину, которая отвечает за окончание работы и выводит сообщение "До свидания".
 * Она может запускаться при любом вышеуказанном исполнении программы в конце.
 */
fun task1() = runBlocking {
    payProduct().join()
    goodbye()
}

private fun CoroutineScope.payProduct() = launch {
    println("Программа покупки продуктов")
    delay(1000L)
    println("Купить товар:\n1.Да\n2.Нет")
    when (readln()) {
        "1" -> agreePay()
        "2" -> cancelPay()
        else -> throw Exception("Введено недопустимое значение")
    }
}

fun CoroutineScope.agreePay() = launch {
    println("Оплата продукта началась")
    delay(2000L)
    println("Сканирование и обработка...")
    delay(2000L)
    println("Покупка оплачена.")
}

fun CoroutineScope.cancelPay() = launch {
    println("Отмена покупки...")
    delay(2000L)
    println("Покупка отменена.")
}

fun goodbye() {
    println("До свидания")
}

/**
 *  2. Написать программу, выводящую в консоль следующее сообщение:
 * Начало программы
 * 1
 * 2
 * Произошел ленивый запуск
 * 3
 * 4
 * Программа завершена
 * Реализацию вывода переменной счетчика необходимо исполнить с помощью корутины с задержкой внутри 1 сек.
 * Вывод строки "Произошел ленивый запуск" выполнить, передав в параметр своей корутины CoroutineStart.LAZY,
 * задержку выдержать в соответствии заявленным выводом (после вывода 2).
 * Сообщение "Программа завершена" также выполняется в своей корутине с отложенным запуском с таким расчетом,
 * чтобы она сработала после полного вывода переменной счетчика.
 */
fun task2() = runBlocking {
    println("Начало программы")
    launch {
        for (i in 1..4) {
            coroutinePrintWithDelay(i.toString(), i == 3).join()
        }
    }.join()
    println("Программа завершена")
}

private fun CoroutineScope.coroutinePrintWithDelay(text: String, isLazy: Boolean) =
    launch(start = if (isLazy) CoroutineStart.LAZY else CoroutineStart.DEFAULT) {
        println(text)
        delay(1000L)
    }.apply {
        if (isLazy) {
            println("Произошел ленивый запуск")
            start()
        }
    }